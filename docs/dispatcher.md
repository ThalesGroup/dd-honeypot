# Dispatcher for Protocol-Aware Honeypot Routing

## Overview

The Dispatcher is a lightweight, protocol-aware front controller that sits in front of multiple honeypots and intelligently routes incoming connections to the appropriate backend honeypot based on early inspection of the attacker’s traffic. This enables exposing only one port per protocol (e.g., one for HTTP, one for SSH, one for MySQL) while internally emulating a variety of services.

The Dispatcher supports advanced routing scenarios based on attacker behavior. For example, if an attacker gains SSH access to a simulated MySQL server and launches the MySQL CLI, the Dispatcher can detect the SQL traffic and forward it to a backend MySQL honeypot that responds accordingly—enabling seamless protocol transitions and realistic multi-layer emulation.

The Dispatcher is particularly effective in capturing lateral movement. Once an attacker breaches one service, any attempt to pivot—such as scanning internal IP ranges, accessing other emulated services, or reusing stolen credentials—can be routed to the appropriate honeypots. This allows researchers to observe realistic attacker workflows as they move across services and protocols, providing deeper insight into post-compromise behavior.

---

## Key Idea

Instead of running many honeypots on many public-facing ports, we use a single entry point per protocol:

- Port 80/443 for HTTP
- Port 22 for SSH
- More ports and protocols can be supported

The Dispatcher:
- Accepts incoming connections
- Reads initial traffic (e.g., HTTP headers, SSH banners, MySQL handshake)
- Identifies the likely target or attack intent (using static rules, dataset, or LLM)
- Proxies the session to the corresponding internal honeypot
- Captures moves between different servers/protocols and routes the traffic to the right honeypot

---

## Internal Network Topology

- Internal honeypots run on private ports or containers.
- The Dispatcher bridges the attacker to the correct honeypot after classification.
- Session is proxied transparently; attacker remains unaware.

---

## Novelty

- **Single public port per protocol** simplifies exposure and hides infrastructure complexity.
- **Dynamic routing** based on early connection behavior, including protocol and command-level inspection, directs traffic to the appropriate honeypot—capabilities that are uncommon in traditional honeypot setups.
- **Advanced routing** enables multi-stage workflows, such as launching a database client over SSH or accessing internal services after initial compromise.
- **Lateral movement detection**: attackers attempting to pivot—by scanning, reusing credentials, or chaining protocols—are seamlessly routed to honeypots that simulate those services, revealing post-exploitation behavior.
- **Increased realism**: attackers encounter services that match their intended target, increasing believability and engagement.
- **Modular architecture**: honeypots can be added, updated, or replaced without changing the external interface, making the system easy to extend.

---

## Technical Details

A dispatcher has a configuration directory just like any other honeypot. Multiple dispatchers can be used (e.g., one for HTTP, one for SSH, one for MySQL, etc.).

### Example Configuration (HTTP)

```json
{
  "type": "http",
  "name": "http dispatcher",
  "is_dispatcher": true,
  "model_id": "anthropic.claude-3-5-sonnet-20240620-v1:0",
  "system_prompt": [
    "You are an http dispatcher. You have to decide the right application target according to the given payload",
    "If there is no way to understand which application is the right target return UNKNOWN and choose one of the application"
  ],
  "honeypots": ["php_my_admin", "boa_server_http"],
  "port": 80
}
```

### Example Routing Data (data.jsonl)

```jsonl
{"path": "/", "name": "UNKNOWN"}
{"path": "/phpmyadmin", "name": "php_my_admin"}
{"path": "/dbadmin", "name": "php_my_admin"}
{"path": "/login.htm", "name": "boa_server_http"}
```

### General Dispatcher Folder Structure

- `config.json` – dispatcher configuration
- `data.jsonl` – static routing data (optional)
- `data_store.db` – SQLite DB for LLM-generated or session data

### How Routing Works

- When the dispatcher starts, it verifies that the honeypot names exist in the configuration.
- It builds a system prompt based on the honeypots list, and can take the description from each honeypot (add a `description` field to all honeypots in the list for richer prompts).
- For each new connection, the dispatcher inspects the initial request/traffic and:
  - Looks up a static route in `data.jsonl` (if present)
  - If not found, uses the LLM with the system prompt to select a backend
  - If the name is `UNKNOWN`, a random honeypot is chosen for the session
  - After a honeypot is chosen, a data handler is searched by name, and the response is generated by the data handler
- Session stickiness: Once a backend is chosen for a session, all subsequent requests in that session are routed to the same backend

---

## Best Practices

- Keep backend honeypot names consistent across config files and folders
- Update the system prompt if you add or remove backend honeypots
- Use clear, unambiguous names in both the config and data files
- Add a `description` field to each honeypot for better LLM routing
- Test routing by sending requests to various paths and verifying the backend responses
- You can use both direct port exposure and dispatcher-based routing for different honeypots

---

## See Also
- [Main README](../README.md)
- [Contributing](../CONTRIBUTING.md)
